import {
  AxisPosition,
  type CreateAxisOptions,
  ExtendedDefaultLinearAxisOptions,
  LinearAxis,
  type PlotModelSerializeOptions,
  TickStyle,
  type TickValuesType,
} from '@/oxyplot'
import { assignObject } from '@/patch'

export interface CreateCategoryAxisOptions extends CreateAxisOptions {
  gapWidth?: number
  isTickCentered?: boolean
  itemsSource?: any[]
  labelField?: string

  labels?: string[]
}

export const DefaultCategoryAxisOptions: CreateCategoryAxisOptions = {
  isTickCentered: false,
  tickStyle: TickStyle.Outside,
  position: AxisPosition.Bottom,
  minimumPadding: 0,
  maximumPadding: 0,
  majorStep: 1,
  gapWidth: 1,

  itemsSource: undefined,
  labelField: undefined,
}

export const ExtendedDefaultCategoryAxisOptions = {
  ...ExtendedDefaultLinearAxisOptions,
  ...DefaultCategoryAxisOptions,
}

/**
 * Represents a category axis.
 * The category axis is using the index of the label collection items as coordinates.
 * If you have 5 categories in the Labels collection, the categories will be placed at coordinates 0 to 4.
 * The range of the axis will be from -0.5 to 4.5 (excluding padding).
 */
export class CategoryAxis extends LinearAxis {
  /**
   * The auto-generated labels.
   */
  private _autoGeneratedLabels: string[] = []

  /**
   * The labels from the ItemsSource.
   */
  private _itemsSourceLabels: string[] = []

  /**
   * Initializes a new instance of the CategoryAxis class.
   */
  constructor(opt?: CreateCategoryAxisOptions) {
    super(opt)
    if (opt?.labels) {
      this._labels = opt.labels
      delete opt.labels
    }
    assignObject(this, DefaultCategoryAxisOptions, opt)
  }

  getElementName() {
    return 'CategoryAxis'
  }

  /**
   * Gets the actual category labels.
   */
  get actualLabels(): string[] {
    if (this.itemsSource) {
      return this._itemsSourceLabels
    }

    if (this.labels.length > 0) {
      return this.labels
    }

    return this._autoGeneratedLabels
  }

  /**
   * Gets or sets the gap width.
   * The default value is 1.0 (100%). The gap width is given as a fraction of the total width/height of the items in a category.
   */
  gapWidth: number = DefaultCategoryAxisOptions.gapWidth!

  /**
   * Gets or sets a value indicating whether the ticks are centered. If this is false, ticks will be drawn between each category. If this is true, ticks will be drawn in the middle of each category.
   */
  isTickCentered: boolean = DefaultCategoryAxisOptions.isTickCentered!

  /**
   * Gets or sets the items source (used to update the Labels collection).
   */
  itemsSource?: any[]

  /**
   * Gets or sets the data field for the labels.
   */
  labelField?: string

  private _labels: string[] = []
  /**
   * Gets the list of category labels.
   */
  get labels(): string[] {
    return this._labels
  }

  /**
   * Gets the actual category labels.
   */
  getTickValues(): TickValuesType {
    const { majorLabelValues, majorTickValues, minorTickValues } = super.getTickValues()
    minorTickValues.length = 0

    if (!this.isTickCentered) {
      const epsilon = 1e-3

      // Subtract 0.5 from the label values to get the tick values.
      // Add one extra tick at the end.
      let mv: number[] = []
      mv = majorLabelValues.map((v) => v - 0.5).filter((v) => v > this.clipMinimum - epsilon)

      if (mv.length > 0) {
        const lastTick = mv[mv.length - 1] + this.majorStep
        if (lastTick < this.clipMaximum + epsilon) {
          mv.push(lastTick)
        }
      }

      majorTickValues.length = 0
      majorTickValues.push(...mv)
    }

    return {
      majorLabelValues,
      majorTickValues,
      minorTickValues,
    }
  }

  /**
   * Gets the value from the axis.
   */
  getValue(x: number): any {
    return this.formatValue(x)
  }

  /**
   * Updates the actual maximum and minimum values of the axis.
   */
  updateActualMaxMin(): void {
    // Update the DataMinimum/DataMaximum from the number of categories
    this.include(-0.5)

    const actualLabels = this.actualLabels

    if (actualLabels.length > 0) {
      this.include(actualLabels.length - 1 + 0.5)
    } else {
      this.include(0.5)
    }

    super.updateActualMaxMin()

    this.minorStep = 1
  }

  /**
   * Updates the category labels.
   */
  updateLabels(numberOfCategories: number): void {
    if (this.itemsSource) {
      this._itemsSourceLabels.length = 0
      const formattedItemsSource: string[] = []
      for (let item of this.itemsSource || []) {
        item = this.labelField ? item[this.labelField] : item
        if (!this.stringFormatter) {
          formattedItemsSource.push(item.toString())
        } else {
          formattedItemsSource.push(this.stringFormatter(item))
        }
      }
      this._itemsSourceLabels.push(...formattedItemsSource)
      return
    }

    if (this.labels.length === 0) {
      if (this._autoGeneratedLabels.length === numberOfCategories) {
        return
      }

      this._autoGeneratedLabels.length = 0
      this._autoGeneratedLabels.push(...Array.from({ length: numberOfCategories }, (_, i) => (i + 1).toString()))
    }
  }

  /**
   * Formats the specified value to a string.
   */
  protected formatValueOverride(x: number): string {
    const index = Math.floor(x)
    const actualLabels = this.actualLabels
    if (index >= 0 && index < actualLabels.length) {
      return actualLabels[index]
    }

    return ''
  }

  protected getElementDefaultValues(): any {
    return ExtendedDefaultCategoryAxisOptions
  }

  toJSON(opt?: PlotModelSerializeOptions): any {
    const json = super.toJSON(opt)
    if (this._labels.length > 0) json.labels = this._labels
    return json
  }
}
